# Семантика языка


## Общая структура программы

Программа состоит из глобальных объявлений переменных, определений функций и главной функции `main`.  
Перед началом выполнения инициализируются глобальные переменные, после чего вызывается функция `main`.  
Внутри функций и блоков инструкции выполняются сверху вниз.

## Типы данных

В языке поддерживаются 5 встроенных типов данных: 

| Тип      | Описание                           | Пример литерала | Соответсвующий тип в C# | Особенности                        |
| -------- | ---------------------------------- | --------------- | ----------------------- | ---------------------------------- |
| `int`    | Целое число (знаковое, 32 бита)    | `123`, `0`      | 32-битный `int`         | от -2 147 483 648 до 2 147 483 647 |
| `float`  | Число с плавающей точкой (64 бита) | `3.14`, `0.5`   | 64-битный `double`      | от 5,0 * 10^-324 до 1,7 * 10^308   |
| `string` | Строка произвольной длины          | `"hello"`       | UTF-16 `string`         | Неизменяемая (как в C#)            |
| `bool`   | Логическое значение                | `true`, `false` | `bool`                  |                -                   |
| `void`   | Отсутствие значения                | –               | `void`                  | Используется только для функций    |

Неявные преобразования типов не поддерживаются.

## Переменные и область видимости

### Объявление переменных
Переменные объявляются с помощью ключевых слов `let` (изменяемая) или `const` (константа):
- Для изменяемой переменной (`let`) инициализатор может отсутствовать. В этом случае переменная получает значение по умолчанию для своего типа:
  - `int` - 0
  - `float` - 0.0
  - `string` - "" (пустая строка)
  - `bool` - false

- Для константы (`const`) инициализатор обязателен всегда
- Тип инициализированного значения должен совпадать с указанным типом переменной
- Вычисленное выражение инициализатора справа присваивается новой переменной

## Область видимости

- Переменные могут быть объявлены:
  - в глобальной области (вне всех блоков до ` main`) - видны во всей программе
  - внутри блоков `{ }` - локальные переменные
- Идентификатор переменной должен быть уникальным в пределах текущей области видимости
- Нельзя использовать идентифакатор до его объявления
- Блок создаёт новую вложенную область видимости:
  - Переменная, объявленная внутри блока, видна только в этом блоке (и во вложенных блоках)
  - Внутри блока можно объявить переменную с тем же именем, что и во внешней области. Внутри блока будет видна новая переменная, внешняя становится недоступной до выхода из блока
  - Время жизни локальной переменной – от точки объявления до конца блока

### Присваивание
Присваивание значения уже объявленной переменной выполняется с помощью оператора `=`, при этом:

- Тип выражения должен совпадать с типом переменной
- Константе (`const`) нельзя присваивать новое значение

## Выражения

### Порядок вычисления
Выражения вычисляются в соответствии с приоритетом и ассоциативностью операций(см. таблицу в описании синтаксиса). Операнды бинарных операций вычисляются слева направо.

Оператор `=` используется только в инструкциях присваивания и не может входить в состав выражений (например, `a = b = c` недопустимо)

### Семантика операций

#### Унарные операции

- Унарный минус `-`: применим только к операндам типа `int` или `float`, возвращает число с противоположным знаком
- Унарное логическое отрицание `!`:  операнд должен быть типа `bool`, отрицает значение, т.е. результат `true`, если операнд `false`, и `false`, если операнд `true`

#### Арифметические бинарные операции

- Умножение `*`, деление `/`, сложение `+`, вычитание `-`: выполняют соответствующие арифметические действия с учётом правил типов. Применимы только к операндам одного типа (`int` или `float`)

#### Логические операции

- Логическое И `&&`: оба операнда должны быть `bool`, вычисляется по short‑circuit:
    - Сначала вычисляется левый операнд
    - Если он равен `false`, результат всего выражения `false`, правый операнд не вычисляется
    - Если левый равен `true`, вычисляется правый операнд и возвращается его значение
- Логическое ИЛИ `||`: оба операнда должны быть `bool`, вычисляется по short‑circuit:
    - Вычисляется левый операнд
    - Если он равен `true`, результат `true`, правый операнд не вычисляется
    - Если левый равен `false`, вычисляется правый операнд и возвращается его значение


#### Операции сравнения 

- Операторы `<`, `>`, `<=`, `>=`, `==`, `!=` применимы к операндам одного типа(`int`, `float`, `string`)
- `bool` поддерживает только `==`, `!=`
- Результат всегда типа bool
- Для чисел сравнение производится по их математическому значению
- Для строк сравнение производиться лексикографически по кодам символов(если одна строка окажется префиксом другой, то более короткая строка считается меньшей)

#### Скобки
- `( )`: изменяют порядок вычисления, выражение в скобках вычисляется первым

### Литералы
- Целые литералы (`123`) имеют тип `int`
- Вещественные литералы (`3.14`) имеют тип `float`
- Строковые литералы (`"hello"`) имеют тип `string`, может быть пустой
- Литералы `true` и `false` имеют тип bool
- Отрицательные числа записываются с помощью унарного минуса перед литералом

## Ввод

`input(идентифакатор)`:
- Ожидает ввод строки с клавиатуры одного слова(последовательности символов, не содержащей пробелов, табуляций, перевода строки). Чтение прекращается при встрече первого пробельного символа 
- Ведущие и завершающие пробелы во введённой строке игнорируются
- Строка преобразуется в тип переменной:
  - Для `int`: ожидается целое число (возможно со знаком). Если преобразование невозможно – ошибка выполнения
  - Для `float`: ожидается число в формате с плавающей точкой (например, `3.14` или `-0.5`). Если преобразование невозможно – ошибка выполнения
  - Для `string`: значение присваивается без пробелов
- Полученное значение сохраняется в переменную

## Вывод

`print(выражение1, выражение2, ...)`:

- Вычисляются все переданные выражения в порядке слева направо
- Поддерживаются типы `int`, `float`, `string`, `bool`
- Вывод значений производится в стандартный поток вывода:
  - `int` – десятичное представление без лишних нулей
  - `float` – представление с плавающей точкой (например, `3.14`), не менее одного знака после запятой
  - `string` – содержимое строки без кавычек
- Значения разделяются одним пробелом
- После вывода всех значений добавляется перевод строки
- Если список выражений пуст (т.е. `print();`), выводится только пустая строка (перевод строки)

## Условная инструкция if

- Условие – выражение типа bool
- Сначала вычисляется условие. Если оно истинно (`true`), выполняется блок инструкций после `if`, остальные ветки пропускается. Иначе, если присутствует ветка `else`, выполняется блок после `else`

## Функции

Функции определяются с помощью ключевого слова `func`:
- параметры – список вида `имя: тип`, разделённый запятыми. Параметры передаются по значению (копируются), внутри функции являются переменными и значение можно изменять, при этом родительская переменная никак не меняется
- Функция должна содержать инструкцию `return` с выражением, если тип возврата не `void`
- Функции могут вызывать другие функции, но рекурсивные вызовы не поддерживаются
- Функции имеют глобальную область видимости: они доступны из любого места программы после точки объявления
- Вызов функции осуществляется по имени со списком аргументов в скобках. Количество и типы аргументов должны соответствовать параметрам функции. Несоответствие вызывает ошибку семантики

## Главная функция main

Программа обязана содержать функцию с именем `main`, типом возврата `void` и без параметров. Она является точкой входа:
- Если функция `main` отсутствует, имеет другой тип возврата или параметры, программа считается некорректной
- После инициализации глобальных переменных выполняется вызов `main()`. Завершение `main` означает завершение программы

## Цикл while
- Условие – выражение типа `bool`. Вычисляется перед каждой итерацией
- Тело цикла выполняется, пока условие истинно
- В теле цикла могут использоваться инструкции `break` и `continue`

## Инструкции break и continue
- `break;` – немедленно завершает выполнение самого внутреннего цикла `while`, в котором находится. Управление передаётся на инструкцию, следующую за этим циклом
- `continue;` – немедленно переходит к следующей итерации самого внутреннего цикла
- Использование `break` или `continue` вне какого-либо цикла является семантической ошибкой

## Инструкция return
- Используется только внутри тела функции
- При выполнении `return` выражение (если есть) вычисляется, затем управление возвращается в точку вызова, и значение становится результатом вызова
- Допускается несколько `return` в разных ветках
- Если тип возврата не `void`:
  - инструкция `return` должна содержать выражение, тип которого точно совпадает с объявленным типом
  - каждый возможный путь выполнения внутри функции должен заканчиваться инструкцией return. Если существует путь, по которому функция может завершиться без выполнения return, это считается семантической ошибкой 
- Если тип возврата `void`:
  - инструкция `return` не может содержать выражение
  - наличие `return` необязательно

## Встроенные функции 

В языке доступны следующие встроенные функции:

- `length(s)` - возвращает длину строки
- `substr(s, start, count): string` - возвращает подстроку, начинающуюся с позиции `start` (индексация с 0) длиной `count`. Если `start` или `count` выходят за границы строки, возникает ошибка выполнения
- `replace(s, old, new)` - заменяет все вхождения подстроки `old` на `new` в строке `s` и возвращает новую строку
- `toInt(s)` - преобразует строку в целое число. Ведущие и завершающие пробелы игнорируются. Если строка не является корректным целым числом - ошибка выполнения
- `toFloat(s)` - преобразует строку в число с плавающей точкой. Ведущие и завершающие пробелы игнорируются. Если строка не является корректным целым числом - ошибка выполнения

## Ошибки которые могут возникнуть во время выполнения
При выполнении программой следующих случаев могут возникать ошибки:
- Деление на ноль в операциях `/`
- Переполнение при арифметических операциях
- Если введённая строка не может быть преобразован в ожмадаемый тип

